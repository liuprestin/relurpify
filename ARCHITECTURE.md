# Relurpify Architecture

The repository ships a secure agentic runtime plus multiple control surfaces. The core framework keeps agents, tools, and LLMs interoperable, while the agent implementations and UIs layer on top; the sections below separate each concern so you can reason about new features without conflating runtime plumbing with agent logic or presentation.

## 1. Agentic Framework

- **Runtime registration & manifest enforcement** – `framework.RegisterAgent` wires the manifest, sandbox, permission manager, audit log, and HITL broker before handing execution over to any agent (`framework/runtime.go:10-116`). The manifest schema (`framework/manifest.go:11-200`) maps security, resource, and agent runtime metadata so each deployment can bake capabilities and restrictions into a reusable artifact.
- **Graph + context + budget** – Every agent builds `framework.Graph` workflows that emit telemetry while respecting parallel branches, checkpoints, and deterministic merges (`framework/graph.go:11-200`). Those graphs run against `framework.Context`, a thread-safe blackboard that stores state, history, snapshots, and compression logs (`framework/context.go:41-198`). `framework.ContextBudget` and the context builder (`framework/context_budget.go:10-174`, `framework/context_builder.go:1-120`) guard token allocations, driving pruning, compression, and history summaries before an LLM sees the prompt.
- **Tools, telemetry, and persistence** – `app/relurpish/runtime.BuildToolRegistry` registers file operations, grep/search helpers, git commands, test linters, and an AST index so agents always get a predictable toolset (`app/relurpish/runtime/runtime.go:198-271`). Language-server adapters such as `tools/lsp_process_client` keep the same JSON-RPC plumbing that editors expect (`tools/lsp_process_client.go:22-200`). Execution traces and budget events flow through the telemetry stack (`framework/telemetry.go:11-174`), while `framework.HybridMemory` preserves session/project/global memories for future runs (`framework/memory.go:14-200`).
- **Security, permissions, and HITL** – The manifest’s `Permissions` section becomes a `framework.PermissionManager` that validates file, executable, network, and IPC scopes plus HITL requirements before any tool runs (`framework/permissions.go:15-200`). Denials bubble up with structured metadata, and the `framework.HITLBroker` exposes buffered approval workflows that the UI consumes (`framework/hitl.go:11-189`).

## 2. Agents implemented on the framework

- **PlannerAgent** – The pattern-based planner breaks work into plan → execute → verify nodes so you can reason about strategy, collect structured plans, and persist summaries/memories (`agents/pattern/planner.go:11-198`).
- **ReActAgent** – A configurable Reason+Act agent threads context strategies, progressive loaders, and budgets through every cycle, making it ideal for general-purpose coding, debugging, or “ask” flows (`agents/pattern/react.go:16-195`).
- **CodingAgent** – This multi-mode wrapper routes instructions into architect, ask, document, or default ReAct delegates, applies manifest-driven tool matrices, and enriches the context before delegating to the underlying graph (`agents/coding_agent.go:12-187`).
- **ExpertCoderAgent** – Now a thin wrapper that pre-configures a planner and coding executor behind an `AgentCoordinator`, it demonstrates the canonical plan-execute cycle and exposes planner/coding capabilities together (`agents/expert_agent.go:9-96`).
- **AgentCoordinator** – Orchestrates indexer/planner/executor/reviewer agents with shared context, recovery retries, dependency-aware step scheduling, and review iterations so complex workflows can run deterministically (`agents/coordinator.go:13-200`).
- **ReflectionAgent** – Wraps a delegate agent with a reviewer loop that reruns tasks until reviews approve, then surfaces structured issues and approval decisions (`agents/pattern/reflection.go:11-196`).
- **EternalAgent** – A specialty agent that streams “CLI mood / hyperstition” chats, keeps looping until cancelled, and writes its own output back into the state so the runtime can track perpetual reasoning (`agents/eternal_agent.go:11-157`).
- **Agent aliases & registries** – The runtime picks a concrete struct based on CLI presets or YAML manifests, so the same framework code can drive planner/react/reflection/expert/coding/eternal behaviors without recompiling (`app/relurpish/runtime/runtime.go:297-339`).

## 3. User-facing surfaces (UI & control)

- **Coding-agent CLI** – `app/cmd` wires the `coding-agent` root command with persistent flags for workspace/config selection (`app/cmd/root.go:1-40`) and exposes `start`, `agents`, `config`, and `session` subcommands. `start` boots workspaces, resolves manifests, registers sandboxes, and runs instructions in named modes (`app/cmd/start.go:18-155`). `agents` helps you list/create/test manifests so custom runtimes stay manageable (`app/cmd/agents.go:16-200`), and `session` records lightweight snapshots for reuse (`app/cmd/session.go:1-94`).
- **Relurpish TUI + runtime** – `relurpish` runs as a Bubble Tea-powered shell with wizard/chat/status flows plus an optional HTTP API server (`app/relurpish/main.go:1-149`). The Relurpish runtime centralizes log/telemetry/memory, loads workspace configs, builds tool registries, wires manifests, and exposes helpers such as `RunTask`, `ExecuteInstruction`, and `StartServer` so the UI and automation scripts share the same agent state (`app/relurpish/runtime/runtime.go:23-459`). The `Config` package normalizes defaults, workspace selections, and persisted wizard choices (`app/relurpish/runtime/config.go:1-143`).
- **TUI components** – The Bubble Tea `Model` drives a prompt/feed/status triad, keeps a spinner/creator for streaming tokens, and renders rich messages that include plan steps, reasoning, diffs, and session metrics (`app/relurpish/tui/model.go:20-199`, `app/relurpish/tui/view.go:1-20`). Slash commands and streaming builders keep the UI responsive while the runtime streams agent outputs (`app/relurpish/tui/commands.go:1-140`, `app/relurpish/tui/streaming.go:1-195`).
- **API & editor surface** – `server.APIServer` exposes `/api/task` and `/api/context` endpoints so automation harnesses can post instructions, while `/api/task` uses the shared context for incremental state (`server/api.go:1-83`). `server.LSPServer` wires editor open/change events, LSP metadata, and `/ai.*` commands (complete/explain/refactor) into the same agent runtime plus tool proxy layer so editors get the same multi-mode agents as the CLI (`server/lsp_server.go:1-177`).
