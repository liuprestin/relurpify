package runtime

import (
	"context"
	"errors"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/lexcodex/relurpify/framework"
	"gopkg.in/yaml.v3"
)

// PermissionProfile controls how aggressively the generated manifest grants
// filesystem access.
type PermissionProfile string

const (
	PermissionProfileReadOnly       PermissionProfile = "read_only"
	PermissionProfileWorkspaceWrite PermissionProfile = "workspace_write"
)

// ManifestSummary is shared across wizard + status views.
type ManifestSummary struct {
	Path        string
	Exists      bool
	AgentName   string
	Runtime     string
	Permissions int
	Network     int
	Error       string
	UpdatedAt   time.Time
}

// WizardSelection captures interactive wizard choices.
type WizardSelection struct {
	Model   string
	Agents  []string
	Profile PermissionProfile
	Tools   []string
}

func (w WizardSelection) PrimaryAgent(fallback string) string {
	for _, agent := range w.Agents {
		if strings.TrimSpace(agent) != "" {
			return agent
		}
	}
	return fallback
}

// DefaultPermissionProfile returns the balanced profile.
func DefaultPermissionProfile() PermissionProfile {
	return PermissionProfileWorkspaceWrite
}

// Description returns a short explanation for UI hints.
func (p PermissionProfile) Description() string {
	switch p {
	case PermissionProfileReadOnly:
		return "Read + list workspace (no writes)."
	case PermissionProfileWorkspaceWrite:
		return "Read/write workspace and run Go toolchain."
	default:
		return string(p)
	}
}

// SaveManifest writes a manifest tailored to the wizard selection and persists
// the workspace configuration for future runs.
func SaveManifest(ctx context.Context, cfg Config, selection WizardSelection) (ManifestSummary, error) {
	agentName := selection.PrimaryAgent(cfg.AgentLabel())
	profile := selection.Profile
	if profile == "" {
		profile = DefaultPermissionProfile()
	}
	perms := buildPermissionSet(cfg.Workspace, profile)
	manifest := framework.AgentManifest{
		APIVersion: "relurpify/v1alpha1",
		Kind:       "AgentManifest",
		Metadata: framework.ManifestMetadata{
			Name:        agentName,
			Version:     time.Now().Format("20060102"),
			Description: buildManifestDescription(selection),
		},
		Spec: framework.ManifestSpec{
			Image:       "ghcr.io/relurpify/runtime:latest",
			Runtime:     "gvisor",
			Permissions: perms,
			Resources: framework.ResourceSpec{Limits: framework.ResourceLimit{
				CPU:    "2",
				Memory: "4Gi",
				DiskIO: "500MBps",
			}},
			Security: framework.SecuritySpec{
				RunAsUser:       1000,
				ReadOnlyRoot:    false,
				NoNewPrivileges: true,
			},
			Audit: framework.AuditSpec{
				Level:         "verbose",
				RetentionDays: 7,
			},
		},
	}
	data, err := yaml.Marshal(manifest)
	if err != nil {
		return ManifestSummary{}, err
	}
	if err := os.MkdirAll(filepath.Dir(cfg.ManifestPath), 0o755); err != nil {
		return ManifestSummary{}, err
	}
	if err := os.WriteFile(cfg.ManifestPath, data, 0o644); err != nil {
		return ManifestSummary{}, err
	}
	workspaceCfg := WorkspaceConfig{
		Model:             selection.Model,
		Agents:            selection.Agents,
		AllowedTools:      selection.Tools,
		PermissionProfile: profile,
		LastUpdated:       time.Now().Unix(),
	}
	if err := SaveWorkspaceConfig(cfg.ConfigPath, workspaceCfg); err != nil {
		return ManifestSummary{}, err
	}
	return summarizeManifest(cfg.ManifestPath), nil
}

func buildPermissionSet(workspace string, profile PermissionProfile) framework.PermissionSet {
	glob := workspaceGlob(workspace)
	perms := framework.PermissionSet{
		FileSystem: []framework.FileSystemPermission{
			{Action: framework.FileSystemRead, Path: glob, Justification: "Read workspace"},
			{Action: framework.FileSystemList, Path: glob, Justification: "List workspace"},
		},
		Executables: []framework.ExecutablePermission{
			{Binary: "go", Args: []string{"*"}},
			{Binary: "bash", Args: []string{"-c"}},
		},
		Network: []framework.NetworkPermission{
			{Direction: "egress", Protocol: "tcp", Host: "localhost", Port: 11434, Description: "Ollama"},
		},
	}
	if profile == PermissionProfileWorkspaceWrite {
		perms.FileSystem = append(perms.FileSystem, framework.FileSystemPermission{Action: framework.FileSystemWrite, Path: glob, Justification: "Modify workspace"})
	}
	return perms
}

func buildManifestDescription(selection WizardSelection) string {
	parts := []string{"Generated by relurpish wizard"}
	if selection.Model != "" {
		parts = append(parts, "model="+selection.Model)
	}
	if len(selection.Agents) > 0 {
		parts = append(parts, "agents="+strings.Join(selection.Agents, ","))
	}
	if len(selection.Tools) > 0 {
		parts = append(parts, "tools="+strings.Join(selection.Tools, ","))
	}
	return strings.Join(parts, " Â· ")
}

func workspaceGlob(workspace string) string {
	cleaned := filepath.Clean(workspace)
	cleaned = filepath.ToSlash(cleaned)
	if strings.HasSuffix(cleaned, "/") {
		return cleaned + "**"
	}
	return cleaned + "/**"
}

// summarizeManifest ensures manifest existence is tracked even when the wizard
// is invoked before a runtime is initialized.
func summarizeManifest(path string) ManifestSummary {
	summary := ManifestSummary{Path: path}
	info, err := os.Stat(path)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			summary.Error = ""
		} else {
			summary.Error = err.Error()
		}
		return summary
	}
	summary.Exists = true
	summary.UpdatedAt = info.ModTime()
	manifest, err := framework.LoadAgentManifest(path)
	if err != nil {
		summary.Error = err.Error()
		return summary
	}
	summary.AgentName = manifest.Metadata.Name
	summary.Runtime = manifest.Spec.Runtime
	summary.Permissions = len(manifest.Spec.Permissions.FileSystem) + len(manifest.Spec.Permissions.Executables)
	summary.Network = len(manifest.Spec.Permissions.Network)
	return summary
}
